# 2. Pythonic code

### 2-1. Creating your own sequence
(1) a wrapper around a standard library object(encapsulation)
- call all of the same methods on that list to make sure that it remains compatible  
```  
class Items:
    def __init__(self, *values):
        self._values = list(values)

    def __len__(self):
        return len(self._values)

    def __getitem__(self, item):
        return self._values.__getitem__(item)
```  

(2) extending the `collections.UserList` base class(inheritance)  
- keep in mind considertions and caveats mentioned in the last part of this chapter  

(3) implementing your own sequence none of above  
- When indexing by a range, the result should be an instance of the same type of the class
- In the range provided by the `slice`, respect the semantics that Python uses, excluding the element at the extending

### 2-2. Context managers
Context managers are a useful feature.  
They correctly respond to a pattern, especially for resource management.  
ex1_1) a simple way of opening files:
```
fd = open(filename)
try:
    process_file(fd)
finally:
    fd.close()
```
ex1_2) a much elegant and Pythonic way:
```
with open(filename) as fd:
    process_file(fd)
```
Context managers consist of two magic methods: `__enter__` and `__exit__`.  

ex2) a possible way of a database backup
```
def stop_database():
    run("systemctl stop postgresql.service")

def start_database():
    run("systemctl start postgresql.service")

class DBHandler:
    def __enter__(self):
        stop_database()
        return self

    def __exit__(self, ex_type, ex_value, ex_traceback):
        start_database()

def db_backup():
    run("pg_dump database")

def main():
    with DBHandler():
        db_backup()
````
> Keep in mind not to accidentally return True on the `__exit__`..  
> If you do, make sure that this is exactly what you want,  
> and that there is a good reason for it.  

### 2-3. Implementing context managers
The `contextlib` module contains a lot of helper functions and objects that can help us write more compact code.  
(1) `contextmanager` decorator  
When the `contextlib.contextmanager` decorator is applied to a function, it converts the code on that function into a context manager.  
The function in question has to be a particular kind of function called a **generator** function, which will separate the statements into what is going to be on the __enter__ and __exit__ magic methods, respectively.
ex1) rewritten code of 2-2. ex2 with the `contextmanager`
```
import contextlib

@contextlib.contextmanager
def db_handler():
    stop_database()
    yield
    start_database()

with db_handler():
    db_backup()
```

(2) `contextlib.ContextDecorator`
This is a mixin base class that provides the logic for applying a decorator to a function that will make it run inside the context manager.  
ex2) extend this class and implement the logic
```
class dbhandler_decorator(contextlib.ContextDecorator):
    def __enter__(self):
        stop_database()

    def __exit__(self, ex_type, ex_value, ex_traceback):
        start_database()

@dbhandler_decorator()
def offline_backup():
    run("pg_dump database")
```
Unlikely 2-2 ex2), there is no `with` statement.  
We just have to call the function, and `offline_backup()` will automatically run inside a context manager.  
As the decorator and the function are completely independent, you cannot get an object that you would like to use inside the context manager.

### 2-4. Properties, attributes, and different types of methods for objects
(1) Underscores in Python  
By default all attributes of an object are public in python.  
Everything that is not strictly part of an object's interface(protected or private) should be kept prefixed with a single underscore (not a double underscore).  
There is a common misconception that some attributes and methods can be actually made private with a double underscore.  
With the double underscores, Python creates a different name for the attribute: `_<class-name>__<attribute-name>`.  
It was created as a means to override different methods of a class that is going to be extended several times, without the risk of having collisions with the method names.  

(2) Properties  
Properties are to be used when we need to define access control to some attributes in an object.  
ex1) an application where users can register only a valid email
```
import re

EMAIL_FORMAT = re.compile(r"[^@]+@[^@]+\.[^@]+")


def is_valid_email(potentially_valid_email: str):
    return re.match(EMAIL_FORMAT, potentially_valid_email) is not none


class User:
    def __init__(self, user_name):
        self.username = user_name
        self._email = none

    @property
    def email(self):
        return self._email

    @email.setter
    def email(self, new_email):
        if not is_valid_email(new_email):
            raise ValueError(f"Can't set {new_email} as it's not a valid email")
            self._email = new_email
```
The above code enables following:
```
>>> u1 = User("jsmith")
>>> u1.email = "jsmith@"
Traceback (most recent call last):
...
ValueError: Can't set jsmith@ as it's not a valid email
>>> u1.email = "jsmith@g.co"
>>> u1.email
'jsmith@g.co'
```
The `@property` decorator is the query that will answer to something, and the `@<property_name>.setter` is the command that will do something.  
Methods should do one thing only.  

### 2-5. Iterable objects
