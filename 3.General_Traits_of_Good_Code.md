# 3. General Traits of Good Code

## 3-1. Design by contract
The idea behind DbC is that instead of implicitly placing in the code what every party is expecting, both parties agree on a contract that, if violated, will raise an exception, clearly stating why it cannot continue.  
In our context, a **contract** is a construction that enforces some rules that must be honored during the communication of software components.  
- Preconditions: all the checks code will do before running (in the code)
- Postconditions: the validations done after the function call is returned (in the code)
- Invariants: the tings that are kept constant while the code of the function is running (in the docstring)
- Side-effects: side-effects of our code (in the docstring)

## 3-2. Defensive programming
Defensive programming is about making all parts of the code able to protect themselves against invalid inputs.
- Error handling: how to handle errors for scenarios that we might expect to occur
- Assertions: how to deal with errors that should never occur

### (1) Error handling
The idea behind error handling is to gracefully respond to these expected errors in an attempt to either continue our program execution or decide to fail if the error turns out to be insurmountable.  
- Value substitution  
In some scenarios, when there is an error and there is a risk of the software producing an incorrect value or failing entirely, we might be able to replace the result with another, safer value.  
Making this decision is a trade-off between robustness and correctness.  
If the application is critical, or the data being handled is too sensitive, this is not an option.

- Error logging
- Exception handling  
When a fault in a function call is due to a problem on one of these external components, then function should clearly and unambiguously notify the rest of the application about errors that cannot be ignored so that they can be addressed accordingly.  
    - Handle exceptions at the right level of abstraction  
    The exception the function is handling has to be consistent with the logic encapsulated on it.  
    ex1-1) an object handling exceptions of different levels
    ```
    class DataTransport:
        """An example of an object handling exceptions of different levels."""

        retry_threshold: int = 5
        retry_n_times: int = 3

        def __init__(self, connector):
            self._connector = connector
            self.connection = None

        def deliver_event(self, event):
            try:
                self.connect()
                data = event.decode()
                self.send(data)
            except ConnectionError as e:
                logger.info("connection error detected: %s", e)
                raise
            except ValueError as e:
                logger.error("%r contains incorrect data: %s", event, e)
                raise

        def connect(self):
            for _ in range(self, retry_n_times):
                try:
                    self.connection = self._connector.connect()
                except Connectionerror as e:
                    logger.info(
                        "%s: attempting new connection in %is",
                        e,
                        self.retry_threshold,
                    )
                    time.sleep(self.retry_threshold)
                else:
                    return self.connection
            raise ConnectionError(
                f"Couldn't connect after {self.retry_n_times} times"
            )

        def send(self, data):
            return self.connection.send(data)
    ```
    The `ConnectionError` should be handled inside the `connect` method.  
    The `ValueError` belongs to the `send` method of the event.  
    We should seperate these fragments into different methods or functions.  

    ex1-2) connection management
    ```
    def connect_with_retry(connector, retry_n_times, retry_threshold=5):
        """Tries to establish the connection of <connector> retrying
        <retry_n_times>.

        If it can connect, returns the connection object.
        If it's not possible after the retries, raises ConnectionError.

        :param connector: An object with a `.connect()` method.
        :param retry_n_times int: The number of times to try to call
            `connector.connect()`.
        :param retry_threshold int: The time lapse between retry calls.
        """

        for _ in range(retry_n_times):
            try:
                return connector.connect()
            except ConnectionError as e:
                logger.info(
                    "%s: attempting new connection in %is",
                    e,
                    retry_threshold
            )
            time.sleep(retry_threshold)
        exc = ConnectionError(f"Couldn't connect after {retry_n_times} times)
        logger.exception(exc)
        raise exc
    ```

    ex1-3) the new version of ex1-1
    ```
    class DataTransport:
        """An example of an object that separates the exception handling by
        abstraction levels.
        """

        retry_threshold: int = 5
        retry_n_times: int = 3

        def __init__(self, connector):
            self._connector = connector
            self.connection = None

        def deliver_event(self, event):
            self.connection = connect_with_retry(
                self._connector, self.retry_n_times, self.retry_threshold
            )
            self.send(event)

        def send(self, event):
            try:
                return self.connection.send(event.decode())
            except ValueError as e:
                logger.error("%r contains incorrect data: %s", event, e)
                raise
    ```
    - Do not expose tracebacks
    - Avoid empty except blocks
    - Include the original exception

### (2) Using assertions in Python

## 3-3. Separation of concerns

## 3-4. Acronyms to live by

## 3-5. Composition and inheritance

## 3-6. Arguments in functions and methods

## 3-7. Final remarks on good practices for software design
